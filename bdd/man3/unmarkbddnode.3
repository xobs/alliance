.\"   $Id: unmarkbddnode.3,v 1.1 2002/03/18 11:26:51 ludo Exp $
.\" @(#)unmarkbddnode.2 2.7 96/07/02 ; Labo masi cao-vlsi; Author : Jacomme Ludovic
.TH UNMARKBDDNODE 3 "October 1, 1997" "ASIM/LIP6" "BDD FUNCTIONS"
.SH NAME
unmarkbddnode \- unmarks \fBbdd\fP node with a specified mask.
.so man1/alc_origin.1
.SH SYNOPSIS
.nf
.if n \{\
.ft B \}
.if t \{\
.ft CR \}
#include "bdd101.h"
long unmarkbddnode( BddSystem, BddNode, Mark )
  bddsystem \(**BddSystem;
  bddnode   \(**BddNode;
  bddunmark    Mark;
.ft R
.fi
.SH PARAMETERS
.TP 20
\fIBddSystem\fP
The \fBbdd\fP system.
.TP
\fIBddNode\fP
The \fBbdd\fP node to unmark.
.TP
\fIMark\fP
The bit mask.
.SH DESCRIPTION
\fBunmarkbddnode\fP unmarks the \fBbdd\fP node \fIBddNode\fP
with the bit mask \fIMark\fP, in the \fBbdd\fP system BddSystem.
If a null pointer is given, the default \fBbdd\fP system is used.
This function does a AND with the field MARK of the \fBbdd\fP node \fIBddNode\fP,
and the complemented bit mask \fIMark\fP.
.br
.SH RETURN VALUE
\fBunmarkbddnode\fP returns the number of the different unmarked nodes. 
.SH EXAMPLE
.ta 3n 6n 9n 12n 15n 18n 21n
.nf
.if n \{\
.ft B \}
.if t \{\
.ft CR \}
#include "bdd101.h"
   bddsystem  \(**BddSystem;
   bddcircuit \(**BddCircuit;
   bddnode    \(**BddNode;
   chain_list \(**Expr;
   BddSystem  = createbddsystem( 100, 1000, 100, 50000 );
   BddCircuit = createbddcircuit( "hello_world", 10, 10, BddSystem );
   Expr = createablbinexpr( ABL_AND,
                            createablatom( "i0" ),
                            createablatom( "i1" ) );
   BddNode = addbddcircuitabl( BddCircuit, Expr );
   freeablexpr( Expr );
   printf( "Number nodes: %ld\n", 
           markbddnode( (bddsystem \(**)0, BddNode, 0x0001 ) );
   unmarkbddnode( (bddsystem \(**)0, BddNode, 0x0001 );
   destroybddsystem( (bddsystem \(**)0 );
   destroybddcircuit( (bddcircuit \(**)0 );
.ft R
.fi
.SH SEE ALSO
.BR bdd (1)


.so man1/alc_bug_report.1

